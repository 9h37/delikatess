La base de données SQL sera utilisée pour indexer les fichiers chiffrés sur l'espace de stockage.
Grâce à elle, on ne chiffrera pas plusieurs fois un même fichier, et on ne transférera pas sur
l'hôte distant plusieurs fois les mêmes données.

Il est donc impératif que la base de données contienne les informations suivantes :

\begin{description}
     \item[hash:] Le hash SHA-256 du fichier non chiffré, il sera utilisé en tant qu'index de la
               base de données SQL.
     \item[path:] Le chemin d'accès vers le fichier chiffré, ainsi pour un fichier chiffré on a le
               hash du fichier non chiffré qui y est associé.
     \item[sent:] La date à laquelle le fichier a été envoyé sur l'hôte distant (ou 0 s'il n'a pas
               été envoyé).
\end{description} ~

Voici par exemple ce que pourra contenir une table :

\noindent \begin{tabular}{| c | c | c |}
     \hline
     e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855 & try/empty.gpg & 1320932458 \\ \hline
     fe19778cf1ce280658154f2b9c01ffbccd825a23460141dcf3794e7a2c0eb629 & oops.gpg & 1315472654 \\ \hline
     f2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2 & test.gpg & 0 \\ \hline
\end{tabular} ~ \newline \newline

On aimerait cependant ne pas avoir à ce soucier du type de la base de données (\textit{MySQL}, \textit{SQLite},
...), il conviendra donc d'utiliser \textit{Django} pour la gestion de la base de données :

\begin{verbatim}
from django.db import models

class DatabaseEntry (models.Model):
     checksum = models.CharField (max_length = 64)
     path     = models.CharField (max_length = 256)
     sent     = models.DateTimeField ()
\end{verbatim}
